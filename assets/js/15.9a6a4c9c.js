(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{171:function(e,t,r){"use strict";r.r(t);var a=r(0),c=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"管理思想"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#管理思想","aria-hidden":"true"}},[e._v("#")]),e._v(" 管理思想")]),e._v(" "),r("p",[e._v("在组件化开发模式中，组件数据共享一直也是复杂应用项目的痛点，基于单向数据流的思想，组件传值变得麻烦，除去父子组件或孙子组件之外，平行组件又或者跨越层级较多的组件之间的通信变的异常繁琐，vue不是很熟悉，应该类似也有API来处理跨多层组件之间的数据共享问题，react下contextAPI可实现跨越多层组件之间的数据共享，但极大的破坏了组件的规范性，使得此类组件很难再进行任何复用，虽然redux增加了项目的复杂度，redux官方也不是很推荐在一些项目中使用react-redux，明确说明-当你还在思考你的项目要不要使用react-redux时，那说明你的项目是不需要使用的，他规定了每个修改数据的动作都要有一个action属性，然后根据action属性进行不同的操作，最终返回一个数据结果，所有有绑定的组件根据最新的状态进行更新。")]),e._v(" "),r("h2",{attrs:{id:"发布订阅"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅","aria-hidden":"true"}},[e._v("#")]),e._v(" 发布订阅")]),e._v(" "),r("p",[e._v("发布订阅模式在任何框架中应用的地方很多，经典的开发思想，MVVM中用来存储更新DOM的操作，数据变更通知所有订阅者更新数据，redux中也不例外，存储有订阅的组件，数据变更时通知所有订阅的组件进行重新渲染(执行render函数)")]),e._v(" "),r("h2",{attrs:{id:"手写简易的react-redux"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#手写简易的react-redux","aria-hidden":"true"}},[e._v("#")]),e._v(" 手写简易的React-Redux")]),e._v(" "),r("p",[e._v("本章节并不实现react-redux的所有功能，主要是讲解react-redux的设计思想的大概的实现方法。")])])}],!1,null,null,null);t.default=c.exports}}]);